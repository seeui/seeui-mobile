{"version":3,"names":[],"mappings":"","sources":["infiniteLoader/InfiniteLoader.js"],"sourcesContent":["/**\n * @file InfiniteLoader\n * @author BabyLillian(719898036@qq.com)\n * @data 2017-06-28\n */\n\nimport {h, Component} from 'preact';\nimport classNames from 'classnames';\nimport LoadMore from './LoadMore';\n\n\n/**\n * 无限加载\n *\n * @class\n */\nexport default class InfiniteLoader extends Component {\n\n\n    static defaultProps = {\n        // 样式前缀\n        prefixCls: 'cui',\n        // 预加载高度范围\n        minHeight: 500,\n        // 最小的touch移动距离\n        minDistance: 10,\n        // element(icon) for default loader when there is no more content\n        loaderDefaultIcon: <LoadMore showLine> 没有更多内容 </LoadMore>,\n        // element(icon) for loading loader\n        loaderLoadingIcon: <LoadMore loading> Loading... </LoadMore>,\n        // element(icon) for more loader\n        loaderMoreIcon: <LoadMore> 上拉加载更多 </LoadMore>,\n        // callback when it's requesting for more content, pass resolve function and finish function\n        onLoadMore() {},\n        // 是否禁止滚动加载\n        disabled: false\n    }\n\n    constructor(props) {\n        super(props);\n\n        this.state = {\n            loading: false,\n            finish: false,\n            // 首次进入页面\n            initFlag: true\n        };\n\n        this.resolveLoading = this.resolveLoading.bind(this);\n        this.finish = this.finish.bind(this);\n        this.scrollHandler = this.scrollHandler.bind(this);\n\n        this.scrollTimer = null;\n    }\n\n    componentDidMount() {\n        window.addEventListener('scroll', this.scrollHandler);\n    }\n\n    componentWillUnmount() {\n        window.removeEventListener('scroll', this.scrollHandler);\n    }\n\n    finish() {\n        this.setState({\n            loading: false,\n            finish: true\n        });\n    }\n\n    resolveLoading() {\n        this.setState({\n            loading: false,\n            finish: false\n        });\n    }\n\n\n    tryLoad() {\n        if (this.props.disabled) {\n            return;\n        }\n\n        let root = document.documentElement;\n\n        // 兼容: Firefox浏览器下documentElement.scrollTop有效\n        let scrollTop = document.body.scrollTop || root.scrollTop;\n\n        if (this.state.loading || root.clientHeight + scrollTop + this.props.minHeight < root.scrollHeight) {\n            return;\n        }\n\n        this.setState({\n            loading: true\n        });\n\n        this.props.onLoadMore(this.resolveLoading, this.finish);\n    }\n\n    touchHandler(e) {\n        let touch = e.touches ? e.touches[0] : e;\n\n        this.setState({\n            startY: touch.clientY || touch.pageY\n        });\n    }\n\n    moveHandler(e) {\n        let touch = e.touches ? e.touches[0] : e;\n        let y = touch.clientY || touch.pageY;\n        let dy = this.state.startY - y;\n\n        // 忽略过小的移动\n        if (dy >= this.props.minDistance) {\n            this.tryLoad();\n        }\n    }\n\n    scrollHandler() {\n        if (this.props.disabled) {\n            return;\n        }\n\n        // setup for scrollend event\n        clearTimeout(this.scrollTimer);\n\n        this.scrollTimer = setTimeout(() => {\n            let root = document.documentElement;\n            let scrollTop = root.scrollTop || document.body.scrollTop;\n            let up = !!(scrollTop - this.state.scrollTop < 0);\n\n            this.setState({scrollTop});\n\n            // 向上滚动\n            if (up) {\n                return;\n            }\n\n            if (this.state.loading\n                || root.clientHeight + scrollTop + this.props.minHeight < root.scrollHeight) {\n\n                return;\n            }\n\n            // 页面刷新时，滚动条不在顶部\n            // 对于这种场景，不抛load事件\n            if (this.state.initFlag && scrollTop > 0) {\n                this.setState({\n                    loading: false,\n                    initFlag: false\n                });\n                return;\n            }\n\n            this.setState({\n                loading: true,\n                initFlag: false\n            });\n\n            this.props.onLoadMore(this.resolveLoading, this.finish);\n        }, 30);\n    }\n\n    render() {\n        const {children, className, loaderLoadingIcon, loaderDefaultIcon, loaderMoreIcon, ...others} = this.props;\n\n        const cls = classNames('cui-infiniteloader', className);\n\n        let loaderStyle = {\n            display: this.state.loading || this.state.finish ? 'block' : 'none'\n        };\n\n        return (\n            <div\n                className={cls}\n                onTouchStart={e => this.touchHandler(e)}\n                onTouchMove={e => this.moveHandler(e)}\n                {...others}\n            >\n                {children}\n                <div style={loaderStyle}>\n                    {this.state.finish ? loaderDefaultIcon : this.state.loading ? loaderLoadingIcon : loaderMoreIcon}\n                </div>\n            </div>\n        );\n    }\n\n}\n"],"file":"InfiniteLoader.js"}