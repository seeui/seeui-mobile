{"version":3,"names":[],"mappings":"","sources":["util/imgCompress.js"],"sourcesContent":["/**\n * @file 前端图片压缩\n * @author liulangyu(liulangyu@baidu.com)\n * @date 2014-10-23\n */\n\n/**\n * 将datauri转为blob(包含有只读原始数据的类文件对象)\n *\n * @inner\n * @param {string} dataURI dataURI字符串\n *\n * @return {Blob} Blob对象\n */\nfunction dataURIToBlob(dataURI) {\n    let byteStr;\n    let parts = dataURI.split(',');\n\n    if (~parts[0].indexOf('base64')) {\n        byteStr = atob(parts[1]);\n    }\n    else {\n        byteStr = decodeURIComponent(parts[1]);\n    }\n\n    let ab = new ArrayBuffer(byteStr.length);\n    let intArray = new Uint8Array(ab);\n\n    for (let i = 0, len = byteStr.length; i < len; i++) {\n        intArray[i] = byteStr.charCodeAt(i);\n    }\n\n    let mimetype = parts[0].split(':')[1].split(';')[0];\n\n    return arrayBufferToBlob(ab, mimetype);\n}\n\n/**\n * arraybuffer转blob\n *\n * @inner\n * @param {ArrayBuffer} buffer 二进制数据\n * @param {string} type filetype\n * @return {Blob} blob文件对象\n */\nfunction arrayBufferToBlob(buffer, type) {\n    let Builder = window.BlobBuilder || window.WebKitBlobBuilder;\n\n    // android不支持直接new Blob, 只能借助blobbuilder.\n    if (Builder) {\n        let bb = new Builder();\n        bb.append(buffer);\n        return bb.getBlob(type);\n    }\n\n    return new Blob([buffer], type ? {type} : {});\n}\n\n/**\n * 获取压缩优化后的blob对象  默认缩放\n *\n * @public\n * @param {Object} opts 配置项\n * @param {Object} opts.file 文件对象\n * @param {number=} opts.width 最大宽度，默认为原图width\n * @param {number=} opts.height 最大高度，默认为原图height\n * @param {number=} opts.quality 压缩质量，默认为1\n * @param {Function=} opts.callback 回调函数，参数为文件对象\n */\n\nexport default function imgCompress(opts = {}) {\n    if (!opts.file) {\n        throw new Error('no required argument: file');\n    }\n\n    if (!opts.callback) {\n        throw new Error('no required argument: callback');\n    }\n\n    let cb = typeof opts.callback === 'function' ? opts.callback : function () {};\n    let quality = opts.quality || 1;\n\n    let file = opts.file;\n\n    // 如果是gif的，就不用压缩了，现在的压缩效果好差!!!\n    // png的，暂时也不压缩了，比例比较小，\n    let notAllowed = ['image/gif', 'image/png'];\n    if (notAllowed.indexOf(file.type) > -1) {\n        cb(file);\n        return;\n    }\n\n    // 如果size大于500K，改变quality\n    if (file.size > 0.5 * 1024 * 1024) {\n        quality = 0.75;\n    }\n\n    let url = window.URL || window.webkitURL || '';\n    if (url) {\n        // 压缩生成的base64数据\n        let retBase64 = '';\n\n        let objectURL = url.createObjectURL(file);\n\n        let img = new Image();\n        img.src = objectURL;\n\n        img.onload = function () {\n            let w = this.width;\n            let h = this.height;\n\n            let maxW = opts.width || w;\n            // let maxH = opts.height || h;\n\n            // TODO 简单缩放，height暂时不处理啦\n            let scale = w / h;\n\n            if (maxW < w) {\n                w = maxW;\n                h = w / scale;\n            }\n\n            let canvas = document.createElement('canvas');\n            let ctx = canvas.getContext('2d');\n\n            canvas.setAttribute('width', w);\n            canvas.setAttribute('height', h);\n            ctx.drawImage(this, 0, 0, w, h);\n\n            // 文件类型处理\n            retBase64 = canvas.toDataURL('image/jpeg', quality);\n\n            let compressedFile = dataURIToBlob(retBase64);\n\n            // 压缩之后，尺寸比原来的大，则还使用原来的文件\n            if (compressedFile.size >= file.size) {\n                compressedFile = file;\n            }\n            cb(compressedFile);\n        };\n    }\n    else {\n        cb(file);\n    }\n}\n"],"file":"imgCompress.js"}