{"version":3,"names":[],"mappings":"","sources":["util/Gesture.js"],"sourcesContent":["/**\n * @file AlloyFinger\n * https://github.com/AlloyTeam/AlloyFinger\n * @author cgzero(cgzero@cgzero.com)\n * @time 2017-07-08\n */\n\nimport {h, Component, cloneElement} from 'preact';\nimport {Children} from 'preact-compat';\n\nexport default class Gesture extends Component {\n    constructor(props) {\n        super(props);\n\n        this.preV = {x: null, y: null};\n        this.pinchStartLen = null;\n        this.scale = 1;\n        this.isDoubleTap = false;\n        this.delta = null;\n        this.last = null;\n        this.now = null;\n        this.end = null;\n        this.multiTouch = false;\n        this.tapTimeout = null;\n        this.longTapTimeout = null;\n        this.singleTapTimeout = null;\n        this.swipeTimeout = null;\n        this.x1 = this.x2 = this.y1 = this.y2 = null;\n        this.preTapPosition = {x: null, y: null};\n    }\n\n    getLen(v) {\n        return Math.sqrt(v.x * v.x + v.y * v.y);\n    }\n\n    dot(v1, v2) {\n        return v1.x * v2.x + v1.y * v2.y;\n    }\n\n    getAngle(v1, v2) {\n        let mr = this.getLen(v1) * this.getLen(v2);\n        if (mr === 0) {\n            return 0;\n        }\n\n        let r = this.dot(v1, v2) / mr;\n        if (r > 1) {\n            r = 1;\n        }\n        return Math.acos(r);\n    }\n\n    cross(v1, v2) {\n        return v1.x * v2.y - v2.x * v1.y;\n    }\n\n    getRotateAngle(v1, v2) {\n        let angle = this.getAngle(v1, v2);\n        if (this.cross(v1, v2) > 0) {\n            angle *= -1;\n        }\n\n        return angle * 180 / Math.PI;\n    }\n\n    _resetState() {\n        this.setState({\n            x: null,\n            y: null,\n            swiping: false,\n            start: 0\n        });\n    }\n\n\n    _emitEvent(name, ...arg) {\n        if (this.props[name]) {\n            this.props[name](...arg);\n        }\n    }\n\n    _handleTouchStart(evt) {\n\n        if (!evt.touches) {\n            return;\n        }\n        this.now = Date.now();\n        this.x1 = evt.touches[0].pageX;\n        this.y1 = evt.touches[0].pageY;\n        this.delta = this.now - (this.last || this.now);\n        if (this.preTapPosition.x !== null) {\n            this.isDoubleTap = (\n                this.delta > 0 && this.delta <= 250\n                    && Math.abs(this.preTapPosition.x - this.x1) < 30\n                    && Math.abs(this.preTapPosition.y - this.y1) < 30\n            );\n        }\n        this.preTapPosition.x = this.x1;\n        this.preTapPosition.y = this.y1;\n        this.last = this.now;\n        let preV = this.preV;\n        let len = evt.touches.length;\n\n        if (len > 1) {\n            this._cancelLongTap();\n            this._cancelSingleTap();\n            let v = {\n                x: evt.touches[1].pageX - this.x1,\n                y: evt.touches[1].pageY - this.y1\n            };\n            preV.x = v.x;\n            preV.y = v.y;\n            this.pinchStartLen = this.getLen(preV);\n            this._emitEvent('onMultipointStart', evt);\n        }\n        this.longTapTimeout = setTimeout(() => {\n            this._emitEvent('onLongTap', evt);\n        }, 750);\n    }\n\n    _handleTouchMove(evt) {\n        let preV = this.preV;\n        let len = evt.touches.length;\n        let currentX = evt.touches[0].pageX;\n        let currentY = evt.touches[0].pageY;\n\n        this.isDoubleTap = false;\n\n        if (len > 1) {\n            let v = {\n                x: evt.touches[1].pageX - currentX,\n                y: evt.touches[1].pageY - currentY\n            };\n\n            if (preV.x !== null) {\n                if (this.pinchStartLen > 0) {\n                    evt.center = {\n                        x: (evt.touches[1].pageX + currentX) / 2,\n                        y: (evt.touches[1].pageY + currentY) / 2\n                    };\n                    evt.scale = this.getLen(v) / this.pinchStartLen;\n                    this._emitEvent('onPinch', evt);\n                }\n                evt.angle = this.getRotateAngle(v, preV);\n                this._emitEvent('onRotate', evt);\n            }\n            preV.x = v.x;\n            preV.y = v.y;\n            this.multiTouch = true;\n        }\n        else {\n            if (this.x2 !== null) {\n                evt.deltaX = currentX - this.x2;\n                evt.deltaY = currentY - this.y2;\n            }\n            else {\n                evt.deltaX = 0;\n                evt.deltaY = 0;\n            }\n            this._emitEvent('onPressMove', evt);\n        }\n        this._cancelLongTap();\n        this.x2 = currentX;\n        this.y2 = currentY;\n\n        if (len > 1) {\n            evt.preventDefault();\n        }\n    }\n\n    _handleTouchCancel() {\n        clearInterval(this.singleTapTimeout);\n        clearInterval(this.tapTimeout);\n        clearInterval(this.longTapTimeout);\n        clearInterval(this.swipeTimeout);\n    }\n\n    _handleTouchEnd(evt) {\n\n        this.end = Date.now();\n        this._cancelLongTap();\n\n        if (evt.touches.length < 2) {\n            this._emitEvent('onMultipointEnd', evt);\n        }\n\n        evt.origin = [this.x1, this.y1];\n        if (this.multiTouch === false) {\n            if (\n                (this.x2 && Math.abs(this.x1 - this.x2) > 30) || (this.y2 && Math.abs(this.preV.y - this.y2) > 30)\n            ) {\n                evt.direction = this._swipeDirection(this.x1, this.x2, this.y1, this.y2);\n                evt.distance = Math.abs(this.x1 - this.x2);\n                this.swipeTimeout = setTimeout(() => {\n                    this._emitEvent('onSwipe', evt);\n                }, 0);\n            }\n            else {\n                this.tapTimeout = setTimeout(() => {\n                    this._emitEvent('onTap', evt);\n                    if (this.isDoubleTap) {\n                        this._emitEvent('onDoubleTap', evt);\n                        clearTimeout(this.singleTapTimeout);\n                        this.isDoubleTap = false;\n                    }\n                    else {\n                        this.singleTapTimeout = setTimeout(() => {\n                            this._emitEvent('onSingleTap', evt);\n                        }, 250);\n                    }\n                }, 0);\n            }\n        }\n\n        this.preV.x = 0;\n        this.preV.y = 0;\n        this.scale = 1;\n        this.pinchStartLen = null;\n        this.x1 = this.x2 = this.y1 = this.y2 = null;\n        this.multiTouch = false;\n    }\n\n    _cancelLongTap() {\n        clearTimeout(this.longTapTimeout);\n    }\n\n    _cancelSingleTap() {\n        clearTimeout(this.singleTapTimeout);\n    }\n\n    _swipeDirection(x1, x2, y1, y2) {\n        if (Math.abs(x1 - x2) > 80 || this.end - this.now < 250) {\n            return Math.abs(x1 - x2) >= Math.abs(y1 - y2)\n                ? (x1 - x2 > 0 ? 'Left' : 'Right')\n                : (y1 - y2 > 0 ? 'Up' : 'Down');\n        }\n        return 'Nochange';\n    }\n\n    render() {\n        return cloneElement(Children.only(this.props.children), {\n            onTouchStart: this._handleTouchStart.bind(this),\n            onTouchMove: this._handleTouchMove.bind(this),\n            onTouchCancel: this._handleTouchCancel.bind(this),\n            onTouchEnd: this._handleTouchEnd.bind(this)\n        });\n    }\n}\n"],"file":"Gesture.js"}