{"version":3,"names":[],"mappings":"","sources":["util/transform.js"],"sourcesContent":["/**\n * @file transformjs\n * https://github.com/AlloyTeam/AlloyTouch/tree/master/transformjs\n * @author cgzero(cgzero@cgzero.com)\n * @time 2017-07-08\n */\n\n/* eslint-disable */\nconst DEG_TO_RAD =  0.017453292519943295;\n\nclass Matrix3D {\n    constructor(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {\n        this.elements = window.Float32Array ? new Float32Array(16) : [];\n        let te = this.elements;\n        te[0] = (n11 !== undefined) ? n11 : 1; te[4] = n12 || 0; te[8] = n13 || 0; te[12] = n14 || 0;\n        te[1] = n21 || 0; te[5] = (n22 !== undefined) ? n22 : 1; te[9] = n23 || 0; te[13] = n24 || 0;\n        te[2] = n31 || 0; te[6] = n32 || 0; te[10] = (n33 !== undefined) ? n33 : 1; te[14] = n34 || 0;\n        te[3] = n41 || 0; te[7] = n42 || 0; te[11] = n43 || 0; te[15] = (n44 !== undefined) ? n44 : 1;\n    }\n\n    set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {\n        let te = this.elements;\n        te[0] = n11; te[4] = n12; te[8] = n13; te[12] = n14;\n        te[1] = n21; te[5] = n22; te[9] = n23; te[13] = n24;\n        te[2] = n31; te[6] = n32; te[10] = n33; te[14] = n34;\n        te[3] = n41; te[7] = n42; te[11] = n43; te[15] = n44;\n        return this;\n    }\n\n    identity() {\n        this.set(\n            1, 0, 0, 0,\n            0, 1, 0, 0,\n            0, 0, 1, 0,\n            0, 0, 0, 1\n        );\n        return this;\n    }\n\n    multiplyMatrices(a, be) {\n\n        let ae = a.elements;\n        let te = this.elements;\n        let a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];\n        let a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];\n        let a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];\n        let a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];\n\n        let b11 = be[0], b12 = be[1], b13 = be[2], b14 = be[3];\n        let b21 = be[4], b22 = be[5], b23 = be[6], b24 = be[7];\n        let b31 = be[8], b32 = be[9], b33 = be[10], b34 = be[11];\n        let b41 = be[12], b42 = be[13], b43 = be[14], b44 = be[15];\n\n        te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\n        te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\n        te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\n        te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\n\n        te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\n        te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\n        te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\n        te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\n\n        te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\n        te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\n        te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\n        te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\n\n        te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\n        te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\n        te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\n        te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\n\n        return this;\n    }\n\n    // 解决角度为90的整数倍导致Math.cos得到极小的数，其实是0。导致不渲染\n    _rounded(value, i) {\n        i = Math.pow(10, i || 15);\n        // default\n        return Math.round(value * i) / i;\n    }\n\n    _arrayWrap(arr) {\n        return window.Float32Array ? new Float32Array(arr) : arr;\n    }\n\n    appendTransform(\n        x, y, z,\n        scaleX, scaleY, scaleZ,\n        rotateX, rotateY, rotateZ,\n        skewX, skewY,\n        originX, originY, originZ\n    ) {\n        let rx = rotateX * DEG_TO_RAD;\n        let cosx = this._rounded(Math.cos(rx));\n        let sinx = this._rounded(Math.sin(rx));\n        let ry = rotateY * DEG_TO_RAD;\n        let cosy = this._rounded(Math.cos(ry));\n        let siny = this._rounded(Math.sin(ry));\n        let rz = rotateZ * DEG_TO_RAD;\n        let cosz = this._rounded(Math.cos(rz * -1));\n        let sinz = this._rounded(Math.sin(rz * -1));\n\n        this.multiplyMatrices(this, this._arrayWrap([\n            1, 0, 0, x,\n            0, cosx, sinx, y,\n            0, -sinx, cosx, z,\n            0, 0, 0, 1\n        ]));\n\n        this.multiplyMatrices(this, this._arrayWrap([\n            cosy, 0, siny, 0,\n            0, 1, 0, 0,\n            -siny, 0, cosy, 0,\n            0, 0, 0, 1\n        ]));\n\n        this.multiplyMatrices(this, this._arrayWrap([\n            cosz * scaleX, sinz * scaleY, 0, 0,\n            -sinz * scaleX, cosz * scaleY, 0, 0,\n            0, 0, 1 * scaleZ, 0,\n            0, 0, 0, 1\n        ]));\n\n        if (skewX || skewY) {\n            this.multiplyMatrices(this, this._arrayWrap([\n                this._rounded(Math.cos(skewX * DEG_TO_RAD)), this._rounded(Math.sin(skewX * DEG_TO_RAD)), 0, 0,\n                -1 * this._rounded(Math.sin(skewY * DEG_TO_RAD)), this._rounded(Math.cos(skewY * DEG_TO_RAD)), 0, 0,\n                0, 0, 1, 0,\n                0, 0, 0, 1\n            ]));\n        }\n\n        if (originX || originY || originZ) {\n            this.elements[12] -= originX * this.elements[0] + originY * this.elements[4] + originZ * this.elements[8];\n            this.elements[13] -= originX * this.elements[1] + originY * this.elements[5] + originZ * this.elements[9];\n            this.elements[14] -= originX * this.elements[2] + originY * this.elements[6] + originZ * this.elements[10];\n        }\n        return this;\n    }\n}\n\nclass Matrix2D {\n    constructor(a, b, c, d, tx, ty) {\n        this.a = a == null ? 1 : a;\n        this.b = b || 0;\n        this.c = c || 0;\n        this.d = d == null ? 1 : d;\n        this.tx = tx || 0;\n        this.ty = ty || 0;\n        return this;\n    }\n\n    identity() {\n        this.a = this.d = 1;\n        this.b = this.c = this.tx = this.ty = 0;\n        return this;\n    }\n\n    appendTransform(x, y, scaleX, scaleY, rotation, skewX, skewY, originX, originY) {\n        let cos;\n        let sin;\n        if (rotation % 360) {\n            let r = rotation * DEG_TO_RAD;\n            cos = Math.cos(r);\n            sin = Math.sin(r);\n        }\n        else {\n            cos = 1;\n            sin = 0;\n        }\n        if (skewX || skewY) {\n            skewX *= DEG_TO_RAD;\n            skewY *= DEG_TO_RAD;\n            this.append(Math.cos(skewY), Math.sin(skewY), -Math.sin(skewX), Math.cos(skewX), x, y);\n            this.append(cos * scaleX, sin * scaleX, -sin * scaleY, cos * scaleY, 0, 0);\n        }\n        else {\n            this.append(cos * scaleX, sin * scaleX, -sin * scaleY, cos * scaleY, x, y);\n        }\n        if (originX || originY) {\n            this.tx -= originX * this.a + originY * this.c;\n            this.ty -= originX * this.b + originY * this.d;\n        }\n        return this;\n    }\n\n    append(a, b, c, d, tx, ty) {\n        let a1 = this.a;\n        let b1 = this.b;\n        let c1 = this.c;\n        let d1 = this.d;\n        this.a = a * a1 + b * c1;\n        this.b = a * b1 + b * d1;\n        this.c = c * a1 + d * c1;\n        this.d = c * b1 + d * d1;\n        this.tx = tx * a1 + ty * c1 + this.tx;\n        this.ty = tx * b1 + ty * d1 + this.ty;\n        return this;\n    }\n\n    initialize(a, b, c, d, tx, ty) {\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        this.d = d;\n        this.tx = tx;\n        this.ty = ty;\n        return this;\n    }\n\n    setValues(a, b, c, d, tx, ty) {\n        this.a = a == null ? 1 : a;\n        this.b = b || 0;\n        this.c = c || 0;\n        this.d = d == null ? 1 : d;\n        this.tx = tx || 0;\n        this.ty = ty || 0;\n        return this;\n    }\n\n    copy(matrix) {\n        return this.setValues(matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx, matrix.ty);\n    }\n}\n\nfunction observe(target, props, callback) {\n    for (let i = 0, len = props.length; i < len; i++) {\n        let prop = props[i];\n        watch(target, prop, callback);\n    }\n}\n\nfunction watch(target, prop, callback) {\n    Object.defineProperty(target, prop, {\n        get() {\n            return this['_' + prop];\n        },\n        set(value) {\n            this['_' + prop] = value;\n            callback();\n        }\n    });\n}\n\nfunction isElement(o) {\n    return (\n        // DOM2\n        typeof HTMLElement === 'object'\n            ? o instanceof HTMLElement\n            : o && typeof o === 'object' && o !== null && o.nodeType === 1 && typeof o.nodeName === 'string'\n    );\n}\n\nfunction Transform(obj, notPerspective) {\n    if (obj.hasOwnProperty('translateX')) {\n        return;\n    }\n\n    let observeProps = [\n        'translateX',\n        'translateY',\n        'translateZ',\n        'scaleX',\n        'scaleY',\n        'scaleZ',\n        'rotateX',\n        'rotateY',\n        'rotateZ',\n        'skewX',\n        'skewY',\n        'originX',\n        'originY',\n        'originZ'\n    ];\n    let objIsElement = isElement(obj);\n    if (!notPerspective) {\n        observeProps.push('perspective');\n    }\n\n    observe(\n        obj,\n        observeProps,\n        function () {\n            let mtx = obj.matrix3d.identity().appendTransform(\n                obj.translateX,\n                obj.translateY,\n                obj.translateZ,\n                obj.scaleX,\n                obj.scaleY,\n                obj.scaleZ,\n                obj.rotateX,\n                obj.rotateY,\n                obj.rotateZ,\n                obj.skewX,\n                obj.skewY,\n                obj.originX,\n                obj.originY,\n                obj.originZ\n            );\n\n            let transform = (notPerspective ? '' : `perspective(${obj.perspective}px)`)\n                + `matrix3d(${Array.prototype.slice.call(mtx.elements).join(',')})`;\n\n            if (objIsElement) {\n                obj.style.transform\n                    = obj.style.msTransform\n                    = obj.style.OTransform\n                    = obj.style.MozTransform\n                    = obj.style.webkitTransform\n                    = transform;\n            }\n            else {\n                obj.transform = transform;\n            }\n        });\n\n    obj.matrix3d = new Matrix3D();\n    if (!notPerspective) {\n        obj.perspective = 500;\n    }\n    obj.scaleX = obj.scaleY = obj.scaleZ = 1;\n    // 由于image自带了x\\y\\z，所有加上translate前缀\n    obj.translateX\n        = obj.translateY\n        = obj.translateZ\n        = obj.rotateX\n        = obj.rotateY\n        = obj.rotateZ\n        = obj.skewX\n        = obj.skewY\n        = obj.originX\n        = obj.originY\n        = obj.originZ\n        = 0;\n}\n\nTransform.getMatrix3D = function (option) {\n    let defaultOption = {\n        translateX: 0,\n        translateY: 0,\n        translateZ: 0,\n        rotateX: 0,\n        rotateY: 0,\n        rotateZ: 0,\n        skewX: 0,\n        skewY: 0,\n        originX: 0,\n        originY: 0,\n        originZ: 0,\n        scaleX: 1,\n        scaleY: 1,\n        scaleZ: 1\n    };\n    for (let key of Object.keys(option)) {\n        defaultOption[key] = option[key];\n    }\n    return new Matrix3D().identity().appendTransform(\n        defaultOption.translateX,\n        defaultOption.translateY,\n        defaultOption.translateZ,\n        defaultOption.scaleX,\n        defaultOption.scaleY,\n        defaultOption.scaleZ,\n        defaultOption.rotateX,\n        defaultOption.rotateY,\n        defaultOption.rotateZ,\n        defaultOption.skewX,\n        defaultOption.skewY,\n        defaultOption.originX,\n        defaultOption.originY,\n        defaultOption.originZ\n    ).elements;\n\n};\n\nTransform.getMatrix2D = function (option) {\n    let defaultOption = {\n        translateX: 0,\n        translateY: 0,\n        rotation: 0,\n        skewX: 0,\n        skewY: 0,\n        originX: 0,\n        originY: 0,\n        scaleX: 1,\n        scaleY: 1\n    };\n    for (let key of Object.keys(option)) {\n        defaultOption[key] = option[key];\n    }\n    return new Matrix2D().identity().appendTransform(\n        defaultOption.translateX,\n        defaultOption.translateY,\n        defaultOption.scaleX,\n        defaultOption.scaleY,\n        defaultOption.rotation,\n        defaultOption.skewX,\n        defaultOption.skewY,\n        defaultOption.originX,\n        defaultOption.originY\n    );\n};\n\nexport default Transform;\n"],"file":"transform.js"}